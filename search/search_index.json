{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Modern Android Development - The Freeletics Way \u00b6 At Freeletics use many of the Jetpack/AndroidX libraries but we don\u2019t always use them in the way they are advertised in Google\u2019s tutorials. This project show cases our own flavored version of Modern Android Development as well as some of our own utilities. This repository is a work in progress. More will be added over time. Navigator \u00b6 The navigator library is a wrapper around AndroidX navigation that allows to separate navigation logic from the UI layer and provides a scalable approach to type safe navigation in a highly modularized code base. For more information check out it\u2019s README . implementation 'com.freeletics.mad:navigator:0.3.0' // when using composables for navigation implementation 'com.freeletics.mad:navigator-compose:0.3.0' // when using fragments for navigation (even if these contain composables) implementation 'com.freeletics.mad:navigator-fragment:0.3.0' StateMachine \u00b6 StateMachine is a very simple interface to implement a StateMachine with the concept of emitting state through a StateFlow and receiving input actions to mutate that state. For an example on how to build such a state machine check out FlowRedux . To connect a StateMachine to a user interface you can look at Renderer for the Android View world. In compose the StateMachine can be observed using produceState() and actions can be dispatched to it by simply launching them from a CoroutineScope created with rememberCoroutineScope() . implementation 'com.freeletics.mad:state-machine:0.3.0' TextResource \u00b6 TextResource is a domain specific model to represent text. Abstracts text whether it a localized String sent by the backend, a simple Android string resource (with or without formatting args) or an Android plurals resource. This way business logic with text can be easily tested without requiring Context and running on a device. For more information about the motivation for this abstraction check out this blog post . implementation 'com.freeletics.mad:text-resource:0.3.0' License \u00b6 Copyright 2021 Freeletics GmbH. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Modern Android Development - The Freeletics Way"},{"location":"#modern-android-development-the-freeletics-way","text":"At Freeletics use many of the Jetpack/AndroidX libraries but we don\u2019t always use them in the way they are advertised in Google\u2019s tutorials. This project show cases our own flavored version of Modern Android Development as well as some of our own utilities. This repository is a work in progress. More will be added over time.","title":"Modern Android Development - The Freeletics Way"},{"location":"#navigator","text":"The navigator library is a wrapper around AndroidX navigation that allows to separate navigation logic from the UI layer and provides a scalable approach to type safe navigation in a highly modularized code base. For more information check out it\u2019s README . implementation 'com.freeletics.mad:navigator:0.3.0' // when using composables for navigation implementation 'com.freeletics.mad:navigator-compose:0.3.0' // when using fragments for navigation (even if these contain composables) implementation 'com.freeletics.mad:navigator-fragment:0.3.0'","title":"Navigator"},{"location":"#statemachine","text":"StateMachine is a very simple interface to implement a StateMachine with the concept of emitting state through a StateFlow and receiving input actions to mutate that state. For an example on how to build such a state machine check out FlowRedux . To connect a StateMachine to a user interface you can look at Renderer for the Android View world. In compose the StateMachine can be observed using produceState() and actions can be dispatched to it by simply launching them from a CoroutineScope created with rememberCoroutineScope() . implementation 'com.freeletics.mad:state-machine:0.3.0'","title":"StateMachine"},{"location":"#textresource","text":"TextResource is a domain specific model to represent text. Abstracts text whether it a localized String sent by the backend, a simple Android string resource (with or without formatting args) or an Android plurals resource. This way business logic with text can be easily tested without requiring Context and running on a device. For more information about the motivation for this abstraction check out this blog post . implementation 'com.freeletics.mad:text-resource:0.3.0'","title":"TextResource"},{"location":"#license","text":"Copyright 2021 Freeletics GmbH. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"navigator/","text":"Navigator \u00b6 This library sits on top of AndroidX Navigation and solves 2 problems that we ran into after starting to adopt it. We believe that navigation should be triggered from the business logic. This way it is easily testable in isolation without having to actually navigate inside a running app. However you usually want to keep Android specific components out of these layers and passing NavController there would risk leaking the Activity. The XML based declaration of destinations did not scale well with our heavily modularized code base. Each screen is usually it\u2019s own feature module and those should stay independent of each other. That effectively meant that each XML file had a single destination and you need to define all ids somewhere else so that feature modules can navigate to each other. Since the code generated by safe-args also lives in the feature module it\u2019s not usable by other features either. That meant that in the end we didn\u2019t get the nice type safety advantages of safe-args and the XML was just boilerplate that didn\u2019t form a real graph in the end. Destinations \u00b6 To replace the XML and get type safety for navigation the library has its own concept of destinations. A destination consists of 2 things: - the declaration of the destination itself which determines what is shown when the destination is navigated to; - the route - a way to reach the destination. NavRoute \u00b6 The route part is represented by the NavRoute interface. Each destination will get its own implementation of this interface and screens can use it to navigate to the destination. The most minimal implementation of NavRoute would be for a screen that doesn\u2019t require any arguments can be a simple Kotlin object: @Parcelize object HomeScreenRoute : NavRoute , Parcelable The more common case when a destination needs arguments passed to it would look like this @Parcelize data class DetailScreenRoute ( val id : String , ) : NavRoute , Parcelable Both of these use Parcelable and Parcelize because internally the library will pass the route to the screen itself so that it can access the parameters. NavDestination \u00b6 The other part of the destination is represented by NavDestination . These work slightly differently based on whether you are using Fragment navigation or pure Compose navigation (a Fragment with composables in it would still count as Fragment navigation). Compose \u00b6 If we take the DetailScreenRoute example from above, declaring the destination for it would look like this val detailScreenDestination : NavDestination = screenDestination < DetailScreenRoute > { route : DetailScreenRoute -> DetailScreen ( route ) } The screenDestination function will return a new NavDestination which is linked to the route that was passed as the generic type parameter. The lambda function then gets an instance of that NavRoute and calls the @Composable function that should be shown. The other 2 functions to create destinations are dialogDestination and bottomSheetDestination - they declare destinations that use a dialog or bottom sheet as a container instead of being shown full screen. These destinations can then be passed to a NavHost by putting them into a set: setContent { NavHost ( startRoute = HomeScreenRoute , // route to the screen that should be shown initially destinations = setOf ( homeDestination , detailScreenDestination ) ) } Fragment \u00b6 The approach for Fragments is very similar val detailScreenDestination : NavDestination = screenDestination < DetailScreenRoute , DetailFragment > () The screenDestination function will return a new NavDestination which is linked to the route that was passed as the first generic type parameter. The second type parameter is the Fragment that will be shown for this destination. Like the compose destination functions there is also dialogDestination to have a DialogFragment destination. bottomSheetDestination does not exist because this would simply be a dialogDestination with a BottomSheetDialogFragment . These destinations can then be passed to a NavHostFragment by putting them into a set: navHostFragment . setGraph ( startRoute = HomeScreenRoute , // route to the screen that should be shown initially destinations = setOf ( homeDestination , detailScreenDestination ) ) Inside a Fragment the requireRoute extension method can be used to obtain the NavRoute used to navigate to it. For example the DetailFragment could do this to obtain DetailScreenRoute and access the id in it: val route = requireRoute < DetailScreenRoute > () Scalability \u00b6 For the simplicity of the examples above the destinations were just kept in a variable and the set was created directly calling NavHost / setGraph . In practice it makes more sense to use dagger multibindings for these: @Module object DetailScreenModule { @Provides @IntoSet fun provideDetailScreenDestinations (): NavDestination = screenDestination < DetailScreenRoute > { DetailScreen ( it ) } } Then an Activity or something else can simply inject a Set<NavDestination> class MainActivity : ComponentActivity () { @Inject lateinit var destinations : Set < NavDestination > override fun onCreate ( savedInstanceState : Bundle ) { super . onCreate () // inject the activity setContent { NavHost ( startRoute = HomeScreenRoute , destinations = destinations ) } } } Nav events \u00b6 The third main class that the library provides is NavEventNavigator . This class solves the first of our 2 problems, triggering navigation from outside the UI layer. For that it has all the primitive navigation operations: // navigate to the destination that the given route leads to navigator . navigateTo ( DetailScreenRoute ( \"some-id\" )) // navigate up in the hierarchy navigator . navigateUp () // navigate to the previous destination in the backstack navigator . navigateBack () // navigate back to the destination belonging to the referenced route and remove all destinations // in between from the back stack, depending on inclusive the destination navigator . navigateBackTo < MainScreenRoute > ( inclusive = false ) These methods can be called from anywhere and it\u2019s safe to hold an instance of the NavEventNavigator in places where it survives configuration changes. For the navigation to actually be executed call handleNavigation(this, navigator) from your one of the Fragment lifecycle methods or NavigationSetup(navigator) from a composable function. It\u2019s possible to simply instantiate an instance of NavEventNavigator but in the Freeletics code base we usually create a subclass in each feature module that has some higher level methods. For example it could have a method that encapsulates the creation of the route: fun navigateToDetail ( id : String ) { navigateTo ( DetailScreenRoute ( id )) } They can also contain more complex logic like navigating to one route or another based on a parameter or first calling navigateBackTo and then navigateTo with a new route. This keeps the navigation logic more separated and it can be easily called from more than one place. Other concepts \u00b6 Multiple back stacks \u00b6 The library provides support for AndroidX Navigation\u2019s multi back stack feature. To use the feature the root of a back stack should use NavRoot instead of NavRoute for it\u2019s route class. Then it\u2019s possible to navigate to the backstack using NavEventNavigator.navigateToRoot(ProfileTabRoot, restoreRootState = false) . This will save the current back stack\u2019s state, clear it and then do one of two things based on the restoreRootState parameter. If it is true and there is one it will restore the back stack that is associated with ProfileTabRoot . If it\u2019s false or there is no matching back stack that was previously saved the destination for ProfileTabRoot will be shown. Handling back clicks \u00b6 NavEventNavigator has a backPresses() method that returns Flow<Unit> which will emit whenever Android\u2019s back button is used. While this Flow is collected the default back handling is disabled. This can be used to for example show a confirmation dialog before navigating back. Activity results \u00b6 External SDKs and the framework often provide an Activity that is supposed to be used with startActivityForResult . AndroidX already introduced ActivityResultContract to simplify handling this and NavEventNavigator uses them to also enable starting them from outside the UI layer and receiving results there. To use the API registerForActivityResult needs to be called with an instance of the wanted ActivityResultContract . This needs to happen before handleNavigation / NavigationSetup is called for the navigator, so it is recommended to do this during the construction of the navigator. The method returns an ActivityResultRequest object that can be then used for two things. It can be passed to navigateForResult(request) to launch the contract. It also has a results property that returns a Flow<O> , where O is the contract\u2019s output type, to make it possible to receive the returned results. This is an example navigator that allow navigating to the camera or the system file picker to take or pick an image: class MyNavigator : NavEventNavigator () { val cameraImageRequest = registerForActivityResult ( ActivityResultContracts . TakePicture ()) val galleryImageRequest = registerForActivityResult ( ActivityResultContracts . GetContent ()) fun takePicture ( uri : Uri ) { // the uri here is the parameter that the TakePicture contract expects navigateForResult ( cameraImageRequest , uri ) } fun pickPicture () { navigateForResult ( galleryImageRequest , \"image/*\" ) } } In the example above cameraImageRequest.results returns a Flow<Boolean> and galleryImageRequest.results a Flow<Uri?> which can both be collected to handle the results. Requesting permissions \u00b6 The Activity result APIs can already be used with ActivityResultContracts.RequestPermission or ActivityResultContracts.RequestMultiplePermissions to also handle requesting Android runtime permission requests. NavEventNavigator provides a slightly higher level API for this. To use this call registerForPermissionResult , which should be done during the construction of the navigator or shortly after. This can then be passed to requestPermissions with one or more permission to request to launch the request. Results can be collected through the Flow<Map<String, PermissionResult>> that is returned by the results property of request. The PermissionResult is the main advantage of using the API instead for the Activity result APIs. Instead of being a simple Boolean for granted/denied it is an enum with GRANTED , DENIED and DENIED_PERMANENTLY . After it receives the result from the contract, the library will internally use Activity.shouldShowRequestPermissionRationale(permission) to figure out if a denial was a permanent, meaning the user won\u2019t be asked again, or not. This is usually not easily possible since it requires a reference to an Activity . An example usage can look like this: class MyNavigator : NavEventNavigator () { // use permissionRequest.results somewhere to handle results val permissionRequest = registerForPermissionsResult () fun requestContactsPermission ( uri : Uri ) { requestPermissions ( permissionRequest , Manifest . permission . CAMERA ) } fun requestLocationPermissions () { requestPermissions ( permissionRequest , Manifest . permission . ACCESS_FINE_LOCATION , Manifest . permission . ACCESS_FINE_LOCATION , ) } } Destination results \u00b6 The last result API of the library is for returning hand handling results from screens inside the app that also use NavEventNavigator . The setup is similar to Activity results and permissions. The registerForNavigationResult<Route, Result> needs to be called during construction of the navigator or shortly after. Route in this case should be the NavRoute class for the curren screen. While Result is the type of the expected result which can be any Parcelable class. The register method will like the others than return a request object, which has results property that returns a Flow<Result> to collect the results. The navigation to the screen from which the result should be returned is a regular call to navigateTo . However the NavRoute class for that target destination should have NavigationResultRequest.Key<Result> as a parameter. An instance of such a Key can be obtained from the key property of the request object. The target screen can then simply call devliverNavigationResult(route.key, result) on its own navigator to send the result and afterwards remove itself from the back stack with navigateBack . The navigator for a hypothetical ScreenA that wants to receive a result from ScreenB would look like this data class MessageResult ( val message : String ): Parcelable class ScreenANavigator : NavEventNavigator () { // use request.results somewhere to handle the results that ScreenB delivers val request = registerForNavigationResult < ScreenARoute , MessageResult > fun navigateToScreenB () { // if needed ScreenBRoute could also have additional parameters navigateTo ( ScreenBRoute ( request . key )) } } And then the navigator for ScreenB class ScreenANavigator ( val route : ScreenBRoute ) : NavEventNavigator () { fun deliverMessage ( message : String ) { deliverNavigationResult ( route . key , MessageResult ( message )) } } Testing \u00b6 The NavEventNavigator exposes a navEvents property that has Flow<NavEvent> as type. On any of the navigation calls this Flow will emit a new NavEvent . To test logic that triggers navigation this can be used together with the Turbine library to assert that the correct events are emitted. navigator . navEvents . test { navigator . navigateTo ( TestRoute ()) assertThat ( awaitItem ). isEqualTo ( NavEvent . NavigateToEvent ( TestRoute ())) navigator . navigateBack () assertThat ( awaitItem ). isEqualTo ( NavEvent . BackEvent ) } This is a very simplified example, in reality the test would most likely not call the navigator itself but some other code that uses the navigator internally.","title":"Navigator"},{"location":"navigator/#navigator","text":"This library sits on top of AndroidX Navigation and solves 2 problems that we ran into after starting to adopt it. We believe that navigation should be triggered from the business logic. This way it is easily testable in isolation without having to actually navigate inside a running app. However you usually want to keep Android specific components out of these layers and passing NavController there would risk leaking the Activity. The XML based declaration of destinations did not scale well with our heavily modularized code base. Each screen is usually it\u2019s own feature module and those should stay independent of each other. That effectively meant that each XML file had a single destination and you need to define all ids somewhere else so that feature modules can navigate to each other. Since the code generated by safe-args also lives in the feature module it\u2019s not usable by other features either. That meant that in the end we didn\u2019t get the nice type safety advantages of safe-args and the XML was just boilerplate that didn\u2019t form a real graph in the end.","title":"Navigator"},{"location":"navigator/#destinations","text":"To replace the XML and get type safety for navigation the library has its own concept of destinations. A destination consists of 2 things: - the declaration of the destination itself which determines what is shown when the destination is navigated to; - the route - a way to reach the destination.","title":"Destinations"},{"location":"navigator/#navroute","text":"The route part is represented by the NavRoute interface. Each destination will get its own implementation of this interface and screens can use it to navigate to the destination. The most minimal implementation of NavRoute would be for a screen that doesn\u2019t require any arguments can be a simple Kotlin object: @Parcelize object HomeScreenRoute : NavRoute , Parcelable The more common case when a destination needs arguments passed to it would look like this @Parcelize data class DetailScreenRoute ( val id : String , ) : NavRoute , Parcelable Both of these use Parcelable and Parcelize because internally the library will pass the route to the screen itself so that it can access the parameters.","title":"NavRoute"},{"location":"navigator/#navdestination","text":"The other part of the destination is represented by NavDestination . These work slightly differently based on whether you are using Fragment navigation or pure Compose navigation (a Fragment with composables in it would still count as Fragment navigation).","title":"NavDestination"},{"location":"navigator/#compose","text":"If we take the DetailScreenRoute example from above, declaring the destination for it would look like this val detailScreenDestination : NavDestination = screenDestination < DetailScreenRoute > { route : DetailScreenRoute -> DetailScreen ( route ) } The screenDestination function will return a new NavDestination which is linked to the route that was passed as the generic type parameter. The lambda function then gets an instance of that NavRoute and calls the @Composable function that should be shown. The other 2 functions to create destinations are dialogDestination and bottomSheetDestination - they declare destinations that use a dialog or bottom sheet as a container instead of being shown full screen. These destinations can then be passed to a NavHost by putting them into a set: setContent { NavHost ( startRoute = HomeScreenRoute , // route to the screen that should be shown initially destinations = setOf ( homeDestination , detailScreenDestination ) ) }","title":"Compose"},{"location":"navigator/#fragment","text":"The approach for Fragments is very similar val detailScreenDestination : NavDestination = screenDestination < DetailScreenRoute , DetailFragment > () The screenDestination function will return a new NavDestination which is linked to the route that was passed as the first generic type parameter. The second type parameter is the Fragment that will be shown for this destination. Like the compose destination functions there is also dialogDestination to have a DialogFragment destination. bottomSheetDestination does not exist because this would simply be a dialogDestination with a BottomSheetDialogFragment . These destinations can then be passed to a NavHostFragment by putting them into a set: navHostFragment . setGraph ( startRoute = HomeScreenRoute , // route to the screen that should be shown initially destinations = setOf ( homeDestination , detailScreenDestination ) ) Inside a Fragment the requireRoute extension method can be used to obtain the NavRoute used to navigate to it. For example the DetailFragment could do this to obtain DetailScreenRoute and access the id in it: val route = requireRoute < DetailScreenRoute > ()","title":"Fragment"},{"location":"navigator/#scalability","text":"For the simplicity of the examples above the destinations were just kept in a variable and the set was created directly calling NavHost / setGraph . In practice it makes more sense to use dagger multibindings for these: @Module object DetailScreenModule { @Provides @IntoSet fun provideDetailScreenDestinations (): NavDestination = screenDestination < DetailScreenRoute > { DetailScreen ( it ) } } Then an Activity or something else can simply inject a Set<NavDestination> class MainActivity : ComponentActivity () { @Inject lateinit var destinations : Set < NavDestination > override fun onCreate ( savedInstanceState : Bundle ) { super . onCreate () // inject the activity setContent { NavHost ( startRoute = HomeScreenRoute , destinations = destinations ) } } }","title":"Scalability"},{"location":"navigator/#nav-events","text":"The third main class that the library provides is NavEventNavigator . This class solves the first of our 2 problems, triggering navigation from outside the UI layer. For that it has all the primitive navigation operations: // navigate to the destination that the given route leads to navigator . navigateTo ( DetailScreenRoute ( \"some-id\" )) // navigate up in the hierarchy navigator . navigateUp () // navigate to the previous destination in the backstack navigator . navigateBack () // navigate back to the destination belonging to the referenced route and remove all destinations // in between from the back stack, depending on inclusive the destination navigator . navigateBackTo < MainScreenRoute > ( inclusive = false ) These methods can be called from anywhere and it\u2019s safe to hold an instance of the NavEventNavigator in places where it survives configuration changes. For the navigation to actually be executed call handleNavigation(this, navigator) from your one of the Fragment lifecycle methods or NavigationSetup(navigator) from a composable function. It\u2019s possible to simply instantiate an instance of NavEventNavigator but in the Freeletics code base we usually create a subclass in each feature module that has some higher level methods. For example it could have a method that encapsulates the creation of the route: fun navigateToDetail ( id : String ) { navigateTo ( DetailScreenRoute ( id )) } They can also contain more complex logic like navigating to one route or another based on a parameter or first calling navigateBackTo and then navigateTo with a new route. This keeps the navigation logic more separated and it can be easily called from more than one place.","title":"Nav events"},{"location":"navigator/#other-concepts","text":"","title":"Other concepts"},{"location":"navigator/#multiple-back-stacks","text":"The library provides support for AndroidX Navigation\u2019s multi back stack feature. To use the feature the root of a back stack should use NavRoot instead of NavRoute for it\u2019s route class. Then it\u2019s possible to navigate to the backstack using NavEventNavigator.navigateToRoot(ProfileTabRoot, restoreRootState = false) . This will save the current back stack\u2019s state, clear it and then do one of two things based on the restoreRootState parameter. If it is true and there is one it will restore the back stack that is associated with ProfileTabRoot . If it\u2019s false or there is no matching back stack that was previously saved the destination for ProfileTabRoot will be shown.","title":"Multiple back stacks"},{"location":"navigator/#handling-back-clicks","text":"NavEventNavigator has a backPresses() method that returns Flow<Unit> which will emit whenever Android\u2019s back button is used. While this Flow is collected the default back handling is disabled. This can be used to for example show a confirmation dialog before navigating back.","title":"Handling back clicks"},{"location":"navigator/#activity-results","text":"External SDKs and the framework often provide an Activity that is supposed to be used with startActivityForResult . AndroidX already introduced ActivityResultContract to simplify handling this and NavEventNavigator uses them to also enable starting them from outside the UI layer and receiving results there. To use the API registerForActivityResult needs to be called with an instance of the wanted ActivityResultContract . This needs to happen before handleNavigation / NavigationSetup is called for the navigator, so it is recommended to do this during the construction of the navigator. The method returns an ActivityResultRequest object that can be then used for two things. It can be passed to navigateForResult(request) to launch the contract. It also has a results property that returns a Flow<O> , where O is the contract\u2019s output type, to make it possible to receive the returned results. This is an example navigator that allow navigating to the camera or the system file picker to take or pick an image: class MyNavigator : NavEventNavigator () { val cameraImageRequest = registerForActivityResult ( ActivityResultContracts . TakePicture ()) val galleryImageRequest = registerForActivityResult ( ActivityResultContracts . GetContent ()) fun takePicture ( uri : Uri ) { // the uri here is the parameter that the TakePicture contract expects navigateForResult ( cameraImageRequest , uri ) } fun pickPicture () { navigateForResult ( galleryImageRequest , \"image/*\" ) } } In the example above cameraImageRequest.results returns a Flow<Boolean> and galleryImageRequest.results a Flow<Uri?> which can both be collected to handle the results.","title":"Activity results"},{"location":"navigator/#requesting-permissions","text":"The Activity result APIs can already be used with ActivityResultContracts.RequestPermission or ActivityResultContracts.RequestMultiplePermissions to also handle requesting Android runtime permission requests. NavEventNavigator provides a slightly higher level API for this. To use this call registerForPermissionResult , which should be done during the construction of the navigator or shortly after. This can then be passed to requestPermissions with one or more permission to request to launch the request. Results can be collected through the Flow<Map<String, PermissionResult>> that is returned by the results property of request. The PermissionResult is the main advantage of using the API instead for the Activity result APIs. Instead of being a simple Boolean for granted/denied it is an enum with GRANTED , DENIED and DENIED_PERMANENTLY . After it receives the result from the contract, the library will internally use Activity.shouldShowRequestPermissionRationale(permission) to figure out if a denial was a permanent, meaning the user won\u2019t be asked again, or not. This is usually not easily possible since it requires a reference to an Activity . An example usage can look like this: class MyNavigator : NavEventNavigator () { // use permissionRequest.results somewhere to handle results val permissionRequest = registerForPermissionsResult () fun requestContactsPermission ( uri : Uri ) { requestPermissions ( permissionRequest , Manifest . permission . CAMERA ) } fun requestLocationPermissions () { requestPermissions ( permissionRequest , Manifest . permission . ACCESS_FINE_LOCATION , Manifest . permission . ACCESS_FINE_LOCATION , ) } }","title":"Requesting permissions"},{"location":"navigator/#destination-results","text":"The last result API of the library is for returning hand handling results from screens inside the app that also use NavEventNavigator . The setup is similar to Activity results and permissions. The registerForNavigationResult<Route, Result> needs to be called during construction of the navigator or shortly after. Route in this case should be the NavRoute class for the curren screen. While Result is the type of the expected result which can be any Parcelable class. The register method will like the others than return a request object, which has results property that returns a Flow<Result> to collect the results. The navigation to the screen from which the result should be returned is a regular call to navigateTo . However the NavRoute class for that target destination should have NavigationResultRequest.Key<Result> as a parameter. An instance of such a Key can be obtained from the key property of the request object. The target screen can then simply call devliverNavigationResult(route.key, result) on its own navigator to send the result and afterwards remove itself from the back stack with navigateBack . The navigator for a hypothetical ScreenA that wants to receive a result from ScreenB would look like this data class MessageResult ( val message : String ): Parcelable class ScreenANavigator : NavEventNavigator () { // use request.results somewhere to handle the results that ScreenB delivers val request = registerForNavigationResult < ScreenARoute , MessageResult > fun navigateToScreenB () { // if needed ScreenBRoute could also have additional parameters navigateTo ( ScreenBRoute ( request . key )) } } And then the navigator for ScreenB class ScreenANavigator ( val route : ScreenBRoute ) : NavEventNavigator () { fun deliverMessage ( message : String ) { deliverNavigationResult ( route . key , MessageResult ( message )) } }","title":"Destination results"},{"location":"navigator/#testing","text":"The NavEventNavigator exposes a navEvents property that has Flow<NavEvent> as type. On any of the navigation calls this Flow will emit a new NavEvent . To test logic that triggers navigation this can be used together with the Turbine library to assert that the correct events are emitted. navigator . navEvents . test { navigator . navigateTo ( TestRoute ()) assertThat ( awaitItem ). isEqualTo ( NavEvent . NavigateToEvent ( TestRoute ())) navigator . navigateBack () assertThat ( awaitItem ). isEqualTo ( NavEvent . BackEvent ) } This is a very simplified example, in reality the test would most likely not call the navigator itself but some other code that uses the navigator internally.","title":"Testing"},{"location":"Javadoc/navigator/","text":"// text-resource text-resource \u00b6 Packages \u00b6 Name com.freeletics.mad.text","title":"Index"},{"location":"Javadoc/navigator/#text-resource","text":"","title":"text-resource"},{"location":"Javadoc/navigator/#packages","text":"Name com.freeletics.mad.text","title":"Packages"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/","text":"// text-resource / com.freeletics.mad.text Package com.freeletics.mad.text \u00b6 Types \u00b6 Name Summary LoadingTextResource [androidJvm] object LoadingTextResource : TextResource A TextResource that represents not yet loaded text. This can not be formatted into a String and is meant as a marker to for example show a placeholder graphic. TextResource [androidJvm] sealed class TextResource : Parcelable A simple text representation that allows you to model text without the need of an Android Context . Functions \u00b6 Name Summary joinToTextResource [androidJvm] fun < T > Iterable < T >. joinToTextResource (separator: String = \u201c, \u201c, transform: ( T ) -> TextResource ): TextResource An extension method to join TextResources mimicking the behavior of joinToString from the Kotlin Standard Library. plus [androidJvm] operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined TextResource.<br>[androidJvm]<br>operator fun [TextResource](-text-resource/index.md).[plus](plus.md)(other: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)): [TextResource](-text-resource/index.md)<br>Join this TextResource with a String into a combined TextResource. setText [androidJvm] fun TextView . setText (textResource: TextResource ?) Set the textResource as the TextView \u2018s text. toTextResource [androidJvm] fun String . toTextResource (): TextResource","title":"Index"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/#package-comfreeleticsmadtext","text":"","title":"Package com.freeletics.mad.text"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/#types","text":"Name Summary LoadingTextResource [androidJvm] object LoadingTextResource : TextResource A TextResource that represents not yet loaded text. This can not be formatted into a String and is meant as a marker to for example show a placeholder graphic. TextResource [androidJvm] sealed class TextResource : Parcelable A simple text representation that allows you to model text without the need of an Android Context .","title":"Types"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/#functions","text":"Name Summary joinToTextResource [androidJvm] fun < T > Iterable < T >. joinToTextResource (separator: String = \u201c, \u201c, transform: ( T ) -> TextResource ): TextResource An extension method to join TextResources mimicking the behavior of joinToString from the Kotlin Standard Library. plus [androidJvm] operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined TextResource.<br>[androidJvm]<br>operator fun [TextResource](-text-resource/index.md).[plus](plus.md)(other: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)): [TextResource](-text-resource/index.md)<br>Join this TextResource with a String into a combined TextResource. setText [androidJvm] fun TextView . setText (textResource: TextResource ?) Set the textResource as the TextView \u2018s text. toTextResource [androidJvm] fun String . toTextResource (): TextResource","title":"Functions"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/join-to-text-resource/","text":"// text-resource / com.freeletics.mad.text / joinToTextResource joinToTextResource \u00b6 [androidJvm]\\ fun < T > Iterable < T >. joinToTextResource (separator: String = \u201c, \u201c, transform: ( T ) -> TextResource ): TextResource An extension method to join TextResources mimicking the behavior of joinToString from the Kotlin Standard Library.","title":"Join to text resource"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/join-to-text-resource/#jointotextresource","text":"[androidJvm]\\ fun < T > Iterable < T >. joinToTextResource (separator: String = \u201c, \u201c, transform: ( T ) -> TextResource ): TextResource An extension method to join TextResources mimicking the behavior of joinToString from the Kotlin Standard Library.","title":"joinToTextResource"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/plus/","text":"// text-resource / com.freeletics.mad.text / plus plus \u00b6 [androidJvm]\\ operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined `TextResource. [androidJvm]\\ operator fun TextResource . plus (other: String ): TextResource Join this TextResource with a String into a combined `TextResource.","title":"Plus"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/plus/#plus","text":"[androidJvm]\\ operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined `TextResource. [androidJvm]\\ operator fun TextResource . plus (other: String ): TextResource Join this TextResource with a String into a combined `TextResource.","title":"plus"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/set-text/","text":"// text-resource / com.freeletics.mad.text / setText setText \u00b6 [androidJvm]\\ fun TextView . setText (textResource: TextResource ?) Set the textResource as the TextView \u2018s text.","title":"Set text"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/set-text/#settext","text":"[androidJvm]\\ fun TextView . setText (textResource: TextResource ?) Set the textResource as the TextView \u2018s text.","title":"setText"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/to-text-resource/","text":"// text-resource / com.freeletics.mad.text / toTextResource toTextResource \u00b6 [androidJvm]\\ fun String . toTextResource (): TextResource","title":"To text resource"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/to-text-resource/#totextresource","text":"[androidJvm]\\ fun String . toTextResource (): TextResource","title":"toTextResource"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-loading-text-resource/","text":"// text-resource / com.freeletics.mad.text / LoadingTextResource LoadingTextResource \u00b6 [androidJvm]\\ object LoadingTextResource : TextResource A TextResource that represents not yet loaded text. This can not be formatted into a String and is meant as a marker to for example show a placeholder graphic. Functions \u00b6 Name Summary describeContents [androidJvm] abstract fun describeContents (): Int format [androidJvm] @Composable @ReadOnlyComposable open override fun format (): Nothing [androidJvm] open override fun format (context: Context ): Nothing Returns the formatted String represented by this TextResource. writeToParcel [androidJvm] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Index"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-loading-text-resource/#loadingtextresource","text":"[androidJvm]\\ object LoadingTextResource : TextResource A TextResource that represents not yet loaded text. This can not be formatted into a String and is meant as a marker to for example show a placeholder graphic.","title":"LoadingTextResource"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-loading-text-resource/#functions","text":"Name Summary describeContents [androidJvm] abstract fun describeContents (): Int format [androidJvm] @Composable @ReadOnlyComposable open override fun format (): Nothing [androidJvm] open override fun format (context: Context ): Nothing Returns the formatted String represented by this TextResource. writeToParcel [androidJvm] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Functions"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-loading-text-resource/format/","text":"// text-resource / com.freeletics.mad.text / LoadingTextResource / format format \u00b6 [androidJvm]\\ open override fun format (context: Context ): Nothing Returns the formatted String represented by this TextResource. [androidJvm]\\ @Composable @ReadOnlyComposable open override fun format (): Nothing","title":"Format"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-loading-text-resource/format/#format","text":"[androidJvm]\\ open override fun format (context: Context ): Nothing Returns the formatted String represented by this TextResource. [androidJvm]\\ @Composable @ReadOnlyComposable open override fun format (): Nothing","title":"format"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/","text":"// text-resource / com.freeletics.mad.text / TextResource TextResource \u00b6 [androidJvm]\\ sealed class TextResource : Parcelable A simple text representation that allows you to model text without the need of an Android Context . Use the various factory methods to create a new instance. Use format with an Android context to get the proper formatted text. Types \u00b6 Name Summary Companion [androidJvm] object Companion Functions \u00b6 Name Summary describeContents [androidJvm] abstract fun describeContents (): Int format [androidJvm] @Composable @ReadOnlyComposable abstract fun format (): String [androidJvm] abstract fun format (context: Context ): String Returns the formatted String represented by this TextResource. writeToParcel [androidJvm] abstract fun writeToParcel (p0: Parcel , p1: Int ) Inheritors \u00b6 Name LoadingTextResource Extensions \u00b6 Name Summary plus [androidJvm] operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined TextResource.<br>[androidJvm]<br>operator fun [TextResource](index.md).[plus](../plus.md)(other: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)): [TextResource](index.md)<br>Join this TextResource with a String into a combined TextResource.","title":"Index"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/#textresource","text":"[androidJvm]\\ sealed class TextResource : Parcelable A simple text representation that allows you to model text without the need of an Android Context . Use the various factory methods to create a new instance. Use format with an Android context to get the proper formatted text.","title":"TextResource"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/#types","text":"Name Summary Companion [androidJvm] object Companion","title":"Types"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/#functions","text":"Name Summary describeContents [androidJvm] abstract fun describeContents (): Int format [androidJvm] @Composable @ReadOnlyComposable abstract fun format (): String [androidJvm] abstract fun format (context: Context ): String Returns the formatted String represented by this TextResource. writeToParcel [androidJvm] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Functions"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/#inheritors","text":"Name LoadingTextResource","title":"Inheritors"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/#extensions","text":"Name Summary plus [androidJvm] operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined TextResource.<br>[androidJvm]<br>operator fun [TextResource](index.md).[plus](../plus.md)(other: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)): [TextResource](index.md)<br>Join this TextResource with a String into a combined TextResource.","title":"Extensions"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/format/","text":"// text-resource / com.freeletics.mad.text / TextResource / format format \u00b6 [androidJvm]\\ abstract fun format (context: Context ): String Returns the formatted String represented by this TextResource. [androidJvm]\\ @Composable @ReadOnlyComposable abstract fun format (): String","title":"Format"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/format/#format","text":"[androidJvm]\\ abstract fun format (context: Context ): String Returns the formatted String represented by this TextResource. [androidJvm]\\ @Composable @ReadOnlyComposable abstract fun format (): String","title":"format"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/","text":"// text-resource / com.freeletics.mad.text / TextResource / Companion Companion \u00b6 [androidJvm]\\ object Companion Functions \u00b6 Name Summary createWithQuantity [androidJvm] fun createWithQuantity (@ PluralsRes id: Int , quantity: Int , vararg args: Any ): TextResource Create a TextResource for the given Android plurals resource id and the given quantity . The args will be when formatting the string to replace any placeholders. invoke [androidJvm] @ JvmName (name = \u201cfromString\u201d) operator fun invoke (text: String ): TextResource Create a TextResource for the given String . A common use case for this is a string sent by the backend that is already localized and formatted. [androidJvm] @ JvmName (name = \u201cfromNullableString\u201d) operator fun invoke (text: String ?): TextResource ? Returns a TextResource for the given String or null if text was null. [androidJvm] @ JvmName (name = \u201cfromStringResource\u201d) operator fun invoke (@ StringRes id: Int , vararg args: Any ): TextResource Create a TextResource for the given Android string resource id. The args will be when formatting the string to replace any placeholders. join [androidJvm] @ JvmStatic @ JvmOverloads fun join (resources: List < TextResource >, separator: String = \u201c, \u201c): TextResource Join the given TextResources into one.","title":"Index"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/#companion","text":"[androidJvm]\\ object Companion","title":"Companion"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/#functions","text":"Name Summary createWithQuantity [androidJvm] fun createWithQuantity (@ PluralsRes id: Int , quantity: Int , vararg args: Any ): TextResource Create a TextResource for the given Android plurals resource id and the given quantity . The args will be when formatting the string to replace any placeholders. invoke [androidJvm] @ JvmName (name = \u201cfromString\u201d) operator fun invoke (text: String ): TextResource Create a TextResource for the given String . A common use case for this is a string sent by the backend that is already localized and formatted. [androidJvm] @ JvmName (name = \u201cfromNullableString\u201d) operator fun invoke (text: String ?): TextResource ? Returns a TextResource for the given String or null if text was null. [androidJvm] @ JvmName (name = \u201cfromStringResource\u201d) operator fun invoke (@ StringRes id: Int , vararg args: Any ): TextResource Create a TextResource for the given Android string resource id. The args will be when formatting the string to replace any placeholders. join [androidJvm] @ JvmStatic @ JvmOverloads fun join (resources: List < TextResource >, separator: String = \u201c, \u201c): TextResource Join the given TextResources into one.","title":"Functions"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/create-with-quantity/","text":"// text-resource / com.freeletics.mad.text / TextResource / Companion / createWithQuantity createWithQuantity \u00b6 [androidJvm]\\ fun createWithQuantity (@ PluralsRes id: Int , quantity: Int , vararg args: Any ): TextResource Create a TextResource for the given Android plurals resource id and the given quantity . The args will be when formatting the string to replace any placeholders.","title":"Create with quantity"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/create-with-quantity/#createwithquantity","text":"[androidJvm]\\ fun createWithQuantity (@ PluralsRes id: Int , quantity: Int , vararg args: Any ): TextResource Create a TextResource for the given Android plurals resource id and the given quantity . The args will be when formatting the string to replace any placeholders.","title":"createWithQuantity"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/invoke/","text":"// text-resource / com.freeletics.mad.text / TextResource / Companion / invoke invoke \u00b6 [androidJvm]\\ @ JvmName (name = \u201cfromString\u201d) operator fun invoke (text: String ): TextResource Create a TextResource for the given String . A common use case for this is a string sent by the backend that is already localized and formatted. [androidJvm]\\ @ JvmName (name = \u201cfromNullableString\u201d) operator fun invoke (text: String ?): TextResource ? Returns a TextResource for the given String or null if text was null. [androidJvm]\\ @ JvmName (name = \u201cfromStringResource\u201d) operator fun invoke (@ StringRes id: Int , vararg args: Any ): TextResource Create a TextResource for the given Android string resource id. The args will be when formatting the string to replace any placeholders.","title":"Invoke"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/invoke/#invoke","text":"[androidJvm]\\ @ JvmName (name = \u201cfromString\u201d) operator fun invoke (text: String ): TextResource Create a TextResource for the given String . A common use case for this is a string sent by the backend that is already localized and formatted. [androidJvm]\\ @ JvmName (name = \u201cfromNullableString\u201d) operator fun invoke (text: String ?): TextResource ? Returns a TextResource for the given String or null if text was null. [androidJvm]\\ @ JvmName (name = \u201cfromStringResource\u201d) operator fun invoke (@ StringRes id: Int , vararg args: Any ): TextResource Create a TextResource for the given Android string resource id. The args will be when formatting the string to replace any placeholders.","title":"invoke"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/join/","text":"// text-resource / com.freeletics.mad.text / TextResource / Companion / join join \u00b6 [androidJvm]\\ @ JvmStatic @ JvmOverloads fun join (resources: List < TextResource >, separator: String = \u201c, \u201c): TextResource Join the given TextResources into one.","title":"Join"},{"location":"Javadoc/navigator/text-resource/com.freeletics.mad.text/-text-resource/-companion/join/#join","text":"[androidJvm]\\ @ JvmStatic @ JvmOverloads fun join (resources: List < TextResource >, separator: String = \u201c, \u201c): TextResource Join the given TextResources into one.","title":"join"},{"location":"Javadoc/state-machine/","text":"// state-machine state-machine \u00b6 Packages \u00b6 Name com.freeletics.mad.statemachine","title":"Index"},{"location":"Javadoc/state-machine/#state-machine","text":"","title":"state-machine"},{"location":"Javadoc/state-machine/#packages","text":"Name com.freeletics.mad.statemachine","title":"Packages"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/","text":"// state-machine / com.freeletics.mad.statemachine Package com.freeletics.mad.statemachine \u00b6 Types \u00b6 Name Summary StateMachine [common] interface StateMachine < State : Any , Action : Any > A state machine that emits State objects through the Flow returned by state . The state can be mutated through actions passed to dispatch .","title":"Index"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/#package-comfreeleticsmadstatemachine","text":"","title":"Package com.freeletics.mad.statemachine"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/#types","text":"Name Summary StateMachine [common] interface StateMachine < State : Any , Action : Any > A state machine that emits State objects through the Flow returned by state . The state can be mutated through actions passed to dispatch .","title":"Types"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/-state-machine/","text":"// state-machine / com.freeletics.mad.statemachine / StateMachine StateMachine \u00b6 [common]\\ interface StateMachine < State : Any , Action : Any > A state machine that emits State objects through the Flow returned by state . The state can be mutated through actions passed to dispatch . Functions \u00b6 Name Summary dispatch [common] abstract suspend fun dispatch (action: Action ) An an Action to the StateMachine . The implementation can mutate the State based on these actions or trigger side effects. Properties \u00b6 Name Summary state [common] abstract val state : Flow< State > A Flow that emits the current state as well as all changes to the state.","title":"Index"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/-state-machine/#statemachine","text":"[common]\\ interface StateMachine < State : Any , Action : Any > A state machine that emits State objects through the Flow returned by state . The state can be mutated through actions passed to dispatch .","title":"StateMachine"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/-state-machine/#functions","text":"Name Summary dispatch [common] abstract suspend fun dispatch (action: Action ) An an Action to the StateMachine . The implementation can mutate the State based on these actions or trigger side effects.","title":"Functions"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/-state-machine/#properties","text":"Name Summary state [common] abstract val state : Flow< State > A Flow that emits the current state as well as all changes to the state.","title":"Properties"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/-state-machine/dispatch/","text":"// state-machine / com.freeletics.mad.statemachine / StateMachine / dispatch dispatch \u00b6 [common]\\ abstract suspend fun dispatch (action: Action ) An an Action to the StateMachine . The implementation can mutate the State based on these actions or trigger side effects.","title":"Dispatch"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/-state-machine/dispatch/#dispatch","text":"[common]\\ abstract suspend fun dispatch (action: Action ) An an Action to the StateMachine . The implementation can mutate the State based on these actions or trigger side effects.","title":"dispatch"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/-state-machine/state/","text":"// state-machine / com.freeletics.mad.statemachine / StateMachine / state state \u00b6 [common]\\ abstract val state : Flow< State > A Flow that emits the current state as well as all changes to the state.","title":"State"},{"location":"Javadoc/state-machine/state-machine/com.freeletics.mad.statemachine/-state-machine/state/#state","text":"[common]\\ abstract val state : Flow< State > A Flow that emits the current state as well as all changes to the state.","title":"state"},{"location":"Javadoc/text-resource/","text":"// text-resource text-resource \u00b6 Packages \u00b6 Name com.freeletics.mad.text","title":"Index"},{"location":"Javadoc/text-resource/#text-resource","text":"","title":"text-resource"},{"location":"Javadoc/text-resource/#packages","text":"Name com.freeletics.mad.text","title":"Packages"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/","text":"// text-resource / com.freeletics.mad.text Package com.freeletics.mad.text \u00b6 Types \u00b6 Name Summary LoadingTextResource [androidJvm] object LoadingTextResource : TextResource A TextResource that represents not yet loaded text. This can not be formatted into a String and is meant as a marker to for example show a placeholder graphic. TextResource [androidJvm] sealed class TextResource : Parcelable A simple text representation that allows you to model text without the need of an Android Context . Functions \u00b6 Name Summary joinToTextResource [androidJvm] fun < T > Iterable < T >. joinToTextResource (separator: String = \u201c, \u201c, transform: ( T ) -> TextResource ): TextResource An extension method to join TextResources mimicking the behavior of joinToString from the Kotlin Standard Library. plus [androidJvm] operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined TextResource.<br>[androidJvm]<br>operator fun [TextResource](-text-resource/index.md).[plus](plus.md)(other: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)): [TextResource](-text-resource/index.md)<br>Join this TextResource with a String into a combined TextResource. setText [androidJvm] fun TextView . setText (textResource: TextResource ?) Set the textResource as the TextView \u2018s text. toTextResource [androidJvm] fun String . toTextResource (): TextResource","title":"Index"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/#package-comfreeleticsmadtext","text":"","title":"Package com.freeletics.mad.text"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/#types","text":"Name Summary LoadingTextResource [androidJvm] object LoadingTextResource : TextResource A TextResource that represents not yet loaded text. This can not be formatted into a String and is meant as a marker to for example show a placeholder graphic. TextResource [androidJvm] sealed class TextResource : Parcelable A simple text representation that allows you to model text without the need of an Android Context .","title":"Types"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/#functions","text":"Name Summary joinToTextResource [androidJvm] fun < T > Iterable < T >. joinToTextResource (separator: String = \u201c, \u201c, transform: ( T ) -> TextResource ): TextResource An extension method to join TextResources mimicking the behavior of joinToString from the Kotlin Standard Library. plus [androidJvm] operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined TextResource.<br>[androidJvm]<br>operator fun [TextResource](-text-resource/index.md).[plus](plus.md)(other: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)): [TextResource](-text-resource/index.md)<br>Join this TextResource with a String into a combined TextResource. setText [androidJvm] fun TextView . setText (textResource: TextResource ?) Set the textResource as the TextView \u2018s text. toTextResource [androidJvm] fun String . toTextResource (): TextResource","title":"Functions"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/join-to-text-resource/","text":"// text-resource / com.freeletics.mad.text / joinToTextResource joinToTextResource \u00b6 [androidJvm]\\ fun < T > Iterable < T >. joinToTextResource (separator: String = \u201c, \u201c, transform: ( T ) -> TextResource ): TextResource An extension method to join TextResources mimicking the behavior of joinToString from the Kotlin Standard Library.","title":"Join to text resource"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/join-to-text-resource/#jointotextresource","text":"[androidJvm]\\ fun < T > Iterable < T >. joinToTextResource (separator: String = \u201c, \u201c, transform: ( T ) -> TextResource ): TextResource An extension method to join TextResources mimicking the behavior of joinToString from the Kotlin Standard Library.","title":"joinToTextResource"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/plus/","text":"// text-resource / com.freeletics.mad.text / plus plus \u00b6 [androidJvm]\\ operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined `TextResource. [androidJvm]\\ operator fun TextResource . plus (other: String ): TextResource Join this TextResource with a String into a combined `TextResource.","title":"Plus"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/plus/#plus","text":"[androidJvm]\\ operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined `TextResource. [androidJvm]\\ operator fun TextResource . plus (other: String ): TextResource Join this TextResource with a String into a combined `TextResource.","title":"plus"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/set-text/","text":"// text-resource / com.freeletics.mad.text / setText setText \u00b6 [androidJvm]\\ fun TextView . setText (textResource: TextResource ?) Set the textResource as the TextView \u2018s text.","title":"Set text"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/set-text/#settext","text":"[androidJvm]\\ fun TextView . setText (textResource: TextResource ?) Set the textResource as the TextView \u2018s text.","title":"setText"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/to-text-resource/","text":"// text-resource / com.freeletics.mad.text / toTextResource toTextResource \u00b6 [androidJvm]\\ fun String . toTextResource (): TextResource","title":"To text resource"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/to-text-resource/#totextresource","text":"[androidJvm]\\ fun String . toTextResource (): TextResource","title":"toTextResource"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-loading-text-resource/","text":"// text-resource / com.freeletics.mad.text / LoadingTextResource LoadingTextResource \u00b6 [androidJvm]\\ object LoadingTextResource : TextResource A TextResource that represents not yet loaded text. This can not be formatted into a String and is meant as a marker to for example show a placeholder graphic. Functions \u00b6 Name Summary describeContents [androidJvm] abstract fun describeContents (): Int format [androidJvm] @Composable @ReadOnlyComposable open override fun format (): Nothing [androidJvm] open override fun format (context: Context ): Nothing Returns the formatted String represented by this TextResource. writeToParcel [androidJvm] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Index"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-loading-text-resource/#loadingtextresource","text":"[androidJvm]\\ object LoadingTextResource : TextResource A TextResource that represents not yet loaded text. This can not be formatted into a String and is meant as a marker to for example show a placeholder graphic.","title":"LoadingTextResource"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-loading-text-resource/#functions","text":"Name Summary describeContents [androidJvm] abstract fun describeContents (): Int format [androidJvm] @Composable @ReadOnlyComposable open override fun format (): Nothing [androidJvm] open override fun format (context: Context ): Nothing Returns the formatted String represented by this TextResource. writeToParcel [androidJvm] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Functions"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-loading-text-resource/format/","text":"// text-resource / com.freeletics.mad.text / LoadingTextResource / format format \u00b6 [androidJvm]\\ open override fun format (context: Context ): Nothing Returns the formatted String represented by this TextResource. [androidJvm]\\ @Composable @ReadOnlyComposable open override fun format (): Nothing","title":"Format"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-loading-text-resource/format/#format","text":"[androidJvm]\\ open override fun format (context: Context ): Nothing Returns the formatted String represented by this TextResource. [androidJvm]\\ @Composable @ReadOnlyComposable open override fun format (): Nothing","title":"format"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/","text":"// text-resource / com.freeletics.mad.text / TextResource TextResource \u00b6 [androidJvm]\\ sealed class TextResource : Parcelable A simple text representation that allows you to model text without the need of an Android Context . Use the various factory methods to create a new instance. Use format with an Android context to get the proper formatted text. Types \u00b6 Name Summary Companion [androidJvm] object Companion Functions \u00b6 Name Summary describeContents [androidJvm] abstract fun describeContents (): Int format [androidJvm] @Composable @ReadOnlyComposable abstract fun format (): String [androidJvm] abstract fun format (context: Context ): String Returns the formatted String represented by this TextResource. writeToParcel [androidJvm] abstract fun writeToParcel (p0: Parcel , p1: Int ) Inheritors \u00b6 Name LoadingTextResource Extensions \u00b6 Name Summary plus [androidJvm] operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined TextResource.<br>[androidJvm]<br>operator fun [TextResource](index.md).[plus](../plus.md)(other: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)): [TextResource](index.md)<br>Join this TextResource with a String into a combined TextResource.","title":"Index"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/#textresource","text":"[androidJvm]\\ sealed class TextResource : Parcelable A simple text representation that allows you to model text without the need of an Android Context . Use the various factory methods to create a new instance. Use format with an Android context to get the proper formatted text.","title":"TextResource"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/#types","text":"Name Summary Companion [androidJvm] object Companion","title":"Types"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/#functions","text":"Name Summary describeContents [androidJvm] abstract fun describeContents (): Int format [androidJvm] @Composable @ReadOnlyComposable abstract fun format (): String [androidJvm] abstract fun format (context: Context ): String Returns the formatted String represented by this TextResource. writeToParcel [androidJvm] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Functions"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/#inheritors","text":"Name LoadingTextResource","title":"Inheritors"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/#extensions","text":"Name Summary plus [androidJvm] operator fun TextResource . plus (other: TextResource ): TextResource Join this TextResource with the other one into a combined TextResource.<br>[androidJvm]<br>operator fun [TextResource](index.md).[plus](../plus.md)(other: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)): [TextResource](index.md)<br>Join this TextResource with a String into a combined TextResource.","title":"Extensions"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/format/","text":"// text-resource / com.freeletics.mad.text / TextResource / format format \u00b6 [androidJvm]\\ abstract fun format (context: Context ): String Returns the formatted String represented by this TextResource. [androidJvm]\\ @Composable @ReadOnlyComposable abstract fun format (): String","title":"Format"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/format/#format","text":"[androidJvm]\\ abstract fun format (context: Context ): String Returns the formatted String represented by this TextResource. [androidJvm]\\ @Composable @ReadOnlyComposable abstract fun format (): String","title":"format"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/","text":"// text-resource / com.freeletics.mad.text / TextResource / Companion Companion \u00b6 [androidJvm]\\ object Companion Functions \u00b6 Name Summary createWithQuantity [androidJvm] fun createWithQuantity (@ PluralsRes id: Int , quantity: Int , vararg args: Any ): TextResource Create a TextResource for the given Android plurals resource id and the given quantity . The args will be when formatting the string to replace any placeholders. invoke [androidJvm] @ JvmName (name = \u201cfromString\u201d) operator fun invoke (text: String ): TextResource Create a TextResource for the given String . A common use case for this is a string sent by the backend that is already localized and formatted. [androidJvm] @ JvmName (name = \u201cfromNullableString\u201d) operator fun invoke (text: String ?): TextResource ? Returns a TextResource for the given String or null if text was null. [androidJvm] @ JvmName (name = \u201cfromStringResource\u201d) operator fun invoke (@ StringRes id: Int , vararg args: Any ): TextResource Create a TextResource for the given Android string resource id. The args will be when formatting the string to replace any placeholders. join [androidJvm] @ JvmStatic @ JvmOverloads fun join (resources: List < TextResource >, separator: String = \u201c, \u201c): TextResource Join the given TextResources into one.","title":"Index"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/#companion","text":"[androidJvm]\\ object Companion","title":"Companion"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/#functions","text":"Name Summary createWithQuantity [androidJvm] fun createWithQuantity (@ PluralsRes id: Int , quantity: Int , vararg args: Any ): TextResource Create a TextResource for the given Android plurals resource id and the given quantity . The args will be when formatting the string to replace any placeholders. invoke [androidJvm] @ JvmName (name = \u201cfromString\u201d) operator fun invoke (text: String ): TextResource Create a TextResource for the given String . A common use case for this is a string sent by the backend that is already localized and formatted. [androidJvm] @ JvmName (name = \u201cfromNullableString\u201d) operator fun invoke (text: String ?): TextResource ? Returns a TextResource for the given String or null if text was null. [androidJvm] @ JvmName (name = \u201cfromStringResource\u201d) operator fun invoke (@ StringRes id: Int , vararg args: Any ): TextResource Create a TextResource for the given Android string resource id. The args will be when formatting the string to replace any placeholders. join [androidJvm] @ JvmStatic @ JvmOverloads fun join (resources: List < TextResource >, separator: String = \u201c, \u201c): TextResource Join the given TextResources into one.","title":"Functions"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/create-with-quantity/","text":"// text-resource / com.freeletics.mad.text / TextResource / Companion / createWithQuantity createWithQuantity \u00b6 [androidJvm]\\ fun createWithQuantity (@ PluralsRes id: Int , quantity: Int , vararg args: Any ): TextResource Create a TextResource for the given Android plurals resource id and the given quantity . The args will be when formatting the string to replace any placeholders.","title":"Create with quantity"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/create-with-quantity/#createwithquantity","text":"[androidJvm]\\ fun createWithQuantity (@ PluralsRes id: Int , quantity: Int , vararg args: Any ): TextResource Create a TextResource for the given Android plurals resource id and the given quantity . The args will be when formatting the string to replace any placeholders.","title":"createWithQuantity"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/invoke/","text":"// text-resource / com.freeletics.mad.text / TextResource / Companion / invoke invoke \u00b6 [androidJvm]\\ @ JvmName (name = \u201cfromString\u201d) operator fun invoke (text: String ): TextResource Create a TextResource for the given String . A common use case for this is a string sent by the backend that is already localized and formatted. [androidJvm]\\ @ JvmName (name = \u201cfromNullableString\u201d) operator fun invoke (text: String ?): TextResource ? Returns a TextResource for the given String or null if text was null. [androidJvm]\\ @ JvmName (name = \u201cfromStringResource\u201d) operator fun invoke (@ StringRes id: Int , vararg args: Any ): TextResource Create a TextResource for the given Android string resource id. The args will be when formatting the string to replace any placeholders.","title":"Invoke"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/invoke/#invoke","text":"[androidJvm]\\ @ JvmName (name = \u201cfromString\u201d) operator fun invoke (text: String ): TextResource Create a TextResource for the given String . A common use case for this is a string sent by the backend that is already localized and formatted. [androidJvm]\\ @ JvmName (name = \u201cfromNullableString\u201d) operator fun invoke (text: String ?): TextResource ? Returns a TextResource for the given String or null if text was null. [androidJvm]\\ @ JvmName (name = \u201cfromStringResource\u201d) operator fun invoke (@ StringRes id: Int , vararg args: Any ): TextResource Create a TextResource for the given Android string resource id. The args will be when formatting the string to replace any placeholders.","title":"invoke"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/join/","text":"// text-resource / com.freeletics.mad.text / TextResource / Companion / join join \u00b6 [androidJvm]\\ @ JvmStatic @ JvmOverloads fun join (resources: List < TextResource >, separator: String = \u201c, \u201c): TextResource Join the given TextResources into one.","title":"Join"},{"location":"Javadoc/text-resource/text-resource/com.freeletics.mad.text/-text-resource/-companion/join/#join","text":"[androidJvm]\\ @ JvmStatic @ JvmOverloads fun join (resources: List < TextResource >, separator: String = \u201c, \u201c): TextResource Join the given TextResources into one.","title":"join"}]}